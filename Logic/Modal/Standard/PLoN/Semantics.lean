import Logic.Vorspiel.BinaryRelations
import Logic.Modal.Standard.Deduction

namespace LO.Modal.Standard

namespace PLoN

structure Frame (Œ±) where
  World : Type*
  [World_inhabited : Inhabited World]
  Rel : Formula Œ± ‚Üí World ‚Üí World ‚Üí Prop

abbrev Frame.default {F : PLoN.Frame Œ±} : F.World := F.World_inhabited.default
scoped notation "Ôπ´" => Frame.default


instance : CoeFun (PLoN.Frame Œ±) (Œª F => Formula Œ± ‚Üí F.World ‚Üí F.World ‚Üí Prop) := ‚ü®Frame.Rel‚ü©

abbrev Frame.Rel' {F : PLoN.Frame Œ±} (p : Formula Œ±) (x y : F.World) := F.Rel p x y
scoped notation:45 x:90 " ‚â∫[" p "] " y:90 => Frame.Rel' p x y


structure FiniteFrame (Œ±) extends Frame Œ± where
  [World_finite : Finite World]

instance : Coe (FiniteFrame Œ±) (Frame Œ±) := ‚ü®Œª F ‚Ü¶ F.toFrame‚ü©


abbrev terminalFrame (Œ±) : FiniteFrame Œ± where
  World := Unit
  Rel := Œª _ _ _ => True


abbrev FrameClass (Œ± : Type*) := Set (PLoN.Frame Œ±)

abbrev FiniteFrameClass (Œ± : Type*) := Set (PLoN.FiniteFrame Œ±)


abbrev FrameClass.restrictFinite (ùîΩ : FrameClass Œ±) : FiniteFrameClass Œ± := { F | F.toFrame ‚àà ùîΩ }

lemma FrameClass.iff_mem_restrictFinite {ùîΩ : FrameClass Œ±} (h : F ‚àà ùîΩ) : (finite : Finite F.World) ‚Üí ‚ü®F‚ü© ‚àà ùîΩ.restrictFinite := by
  simp_all [FrameClass.restrictFinite];

@[simp]
def FiniteFrameClass.toFrameClass (ùîΩ : FiniteFrameClass Œ±) : FrameClass Œ± := { F | ‚àÉ F', F' ‚àà ùîΩ ‚àß F'.toFrame = F }

abbrev FrameClass.restrictFinite' (ùîΩ : FrameClass Œ±) : FrameClass Œ± := ùîΩ.restrictFinite.toFrameClass
postfix:max "Íü≥" => FrameClass.restrictFinite'


abbrev Valuation (F : PLoN.Frame Œ±) (Œ± : Type*) := F.World ‚Üí Œ± ‚Üí Prop

structure Model (Œ±) where
  Frame : PLoN.Frame Œ±
  Valuation : PLoN.Valuation Frame Œ±

abbrev Model.World (M : PLoN.Model Œ±) := M.Frame.World
instance : CoeSort (PLoN.Model Œ±) (Type _) := ‚ü®Model.World‚ü©

structure FiniteModel (Œ±) extends Model Œ± where
  [World_finite : Finite World]

abbrev FiniteModel.FiniteFrame (M : PLoN.FiniteModel Œ±) : PLoN.FiniteFrame Œ± := { toFrame := M.Frame, World_finite := M.World_finite }

end PLoN

variable {Œ± : Type*}

open Standard.PLoN

def Formula.PLoN.Satisfies (M : PLoN.Model Œ±) (w : M.World) : Formula Œ± ‚Üí Prop
  | atom a  => M.Valuation w a
  | verum   => True
  | falsum  => False
  | neg p   => ¬¨(PLoN.Satisfies M w p)
  | and p q => (PLoN.Satisfies M w p) ‚àß (PLoN.Satisfies M w q)
  | or p q  => (PLoN.Satisfies M w p) ‚à® (PLoN.Satisfies M w q)
  | imp p q => (PLoN.Satisfies M w p) ‚Üí (PLoN.Satisfies M w q)
  | box p   => ‚àÄ {w'}, w ‚â∫[p] w' ‚Üí (PLoN.Satisfies M w' p)


namespace Formula.PLoN.Satisfies

protected instance semantics (M : PLoN.Model Œ±) : Semantics (Formula Œ±) (M.World) := ‚ü®fun w ‚Ü¶ Formula.PLoN.Satisfies M w‚ü©

variable {M : PLoN.Model Œ±} {w : M.World} {p q : Formula Œ±}

@[simp] protected lemma iff_models : w ‚äß p ‚Üî PLoN.Satisfies M w p := by rfl

instance : Semantics.Tarski M.World where
  realize_top := by simp [PLoN.Satisfies];
  realize_bot := by simp [PLoN.Satisfies];
  realize_not := by simp [PLoN.Satisfies];
  realize_and := by simp [PLoN.Satisfies];
  realize_or  := by simp [PLoN.Satisfies];
  realize_imp := by simp [PLoN.Satisfies];

end Formula.PLoN.Satisfies


def Formula.PLoN.ValidOnModel (M : PLoN.Model Œ±) (p : Formula Œ±) : Prop := ‚àÄ w : M.World, w ‚äß p

namespace Formula.PLoN.ValidOnModel

instance : Semantics (Formula Œ±) (PLoN.Model Œ±) := ‚ü®fun M ‚Ü¶ Formula.PLoN.ValidOnModel M‚ü©

@[simp]
protected lemma iff_models {M : PLoN.Model Œ±} {p : Formula Œ±}
: M ‚äß p ‚Üî Formula.PLoN.ValidOnModel M p := by rfl

instance : Semantics.Bot (PLoN.Model Œ±) where
  realize_bot _ := by
    simp [Formula.PLoN.ValidOnModel];
    use Ôπ´;

end Formula.PLoN.ValidOnModel


def Formula.PLoN.ValidOnFrame (F : PLoN.Frame Œ±) (p : Formula Œ±) := ‚àÄ V, (Model.mk F V) ‚äß p

namespace Formula.PLoN.ValidOnFrame

instance : Semantics (Formula Œ±) (PLoN.Frame Œ±) := ‚ü®fun F ‚Ü¶ Formula.PLoN.ValidOnFrame F‚ü©

@[simp]
protected lemma iff_models {F : PLoN.Frame Œ±} {p : Formula Œ±}
: F ‚äß p ‚Üî Formula.PLoN.ValidOnFrame F p := by rfl

variable {F : Frame Œ±}

instance : Semantics.Bot (PLoN.Frame Œ±) where
  realize_bot _ := by simp [Formula.PLoN.ValidOnFrame];

protected lemma nec (h : F ‚äß p) : F ‚äß ‚ñ°p := by
  intro V x y _;
  exact h V y;

protected lemma mdp (hpq : F ‚äß p ‚ü∂ q) (hp : F ‚äß p) : F ‚äß q := by
  intro V x;
  exact (hpq V x) (hp V x);

protected lemma disj‚ÇÉ : F ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ p ‚ãé q ‚ü∂ r := by
  intro V x hpr hqr hpq;
  cases hpq with
  | inl hp => exact hpr hp;
  | inr hq => exact hqr hq;

end Formula.PLoN.ValidOnFrame


def Formula.PLoN.ValidOnFrameClass (ùîΩ : PLoN.FrameClass Œ±) (p : Formula Œ±) := ‚àÄ {F}, F ‚àà ùîΩ ‚Üí F ‚äß p

namespace Formula.PLoN.ValidOnFrameClass

instance : Semantics (Formula Œ±) (PLoN.FrameClass Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Formula.PLoN.ValidOnFrameClass ùîΩ‚ü©

variable {ùîΩ : FrameClass Œ±}

@[simp]
protected lemma iff_models {ùîΩ : PLoN.FrameClass Œ±} {p : Formula Œ±} : ùîΩ ‚äß p ‚Üî Formula.PLoN.ValidOnFrameClass ùîΩ p := by rfl

protected lemma nec (h : ùîΩ ‚äß p) : ùîΩ ‚äß ‚ñ°p := by
  intro _ hF;
  apply PLoN.ValidOnFrame.nec;
  exact h hF;

protected lemma mdp (hpq : ùîΩ ‚äß p ‚ü∂ q) (hp : ùîΩ ‚äß p) : ùîΩ ‚äß q := by
  intro _ hF;
  exact PLoN.ValidOnFrame.mdp (hpq hF) (hp hF)

protected lemma disj‚ÇÉ : ùîΩ ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ p ‚ãé q ‚ü∂ r := by
  intro _ _;
  exact PLoN.ValidOnFrame.disj‚ÇÉ;

end Formula.PLoN.ValidOnFrameClass


def DeductionParameter.CharacterizedByPLoNFrameClass (ùìì : DeductionParameter Œ±) (ùîΩ : PLoN.FrameClass Œ±) := ‚àÄ {F : Frame Œ±}, F ‚àà ùîΩ ‚Üí F ‚äß* ùìì.theory

-- MEMO: `‚Üê`ÊñπÂêë„ÅØÊàê„ÇäÁ´ã„Åü„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çã
def DeductionParameter.DefinesPLoNFrameClass (ùìì : DeductionParameter Œ±) (ùîΩ : PLoN.FrameClass Œ±) := ‚àÄ {F : Frame Œ±}, F ‚äß* ùìì.theory ‚Üî F ‚àà ùîΩ

namespace PLoN

open Formula.PLoN

abbrev AllFrameClass (Œ±) : FrameClass Œ± := Set.univ

lemma AllFrameClass.nonempty : (AllFrameClass.{_, 0} Œ±).Nonempty := by
  use terminalFrame Œ±
  trivial;

open Formula

lemma N_characterized : ùêç.CharacterizedByPLoNFrameClass (AllFrameClass Œ±) := by
  intro F;
  simp [DeductionParameter.theory, System.theory, PLoN.ValidOnFrame, PLoN.ValidOnModel];
  intro p hp;
  induction hp using Deduction.inducition_with_necOnly! with
  | hMaxm h => simp at h;
  | hMdp ihpq ihp => exact PLoN.ValidOnFrame.mdp ihpq ihp;
  | hNec ihp => exact PLoN.ValidOnFrame.nec ihp;
  | hOrElim => exact PLoN.ValidOnFrame.disj‚ÇÉ;
  | _ => simp_all [PLoN.Satisfies];


namespace Frame

variable (F : Frame Œ±)

def SerialOnFormula (p : Formula Œ±) : Prop := Serial (F.Rel' p)

def SerialOnTheory (T : Theory Œ±) : Prop := ‚àÄ p ‚àà ‚ñ°''‚Åª¬πT, F.SerialOnFormula p

protected def Serial : Prop := F.SerialOnTheory Set.univ

/-
lemma serialOnTheory_of_serial (hSerial : F.Serial) : F.SerialOnTheory T := by
  intro q _;
  exact hSerial q;
-/

def TransitiveOnFormula (p : Formula Œ±) : Prop := ‚àÄ {x y z : F.World}, x ‚â∫[‚ñ°p] y ‚Üí y ‚â∫[p] z ‚Üí x ‚â∫[p] z

def TransitiveOnTheory (T : Theory Œ±) : Prop := ‚àÄ p ‚àà ‚ñ°''‚Åª¬π^[2]T, F.TransitiveOnFormula p

protected def Transitive (F : Frame Œ±) := F.TransitiveOnTheory Set.univ

/-
lemma transitiveOnTheory_of_transitive (hTrans : F.Transitive) : F.TransitiveOnTheory T := by
  intro q _; exact hTrans q;
-/

end Frame


open System

lemma validRosserRule_of_serial {p : Formula Œ±} {F : PLoN.Frame Œ±} (hSerial : F.SerialOnFormula p) (h : F ‚äß ~p) : F ‚äß ~(‚ñ°p) := by
  intro V x;
  obtain ‚ü®y, hy‚ü© := hSerial x;
  simp [Formula.PLoN.Satisfies];
  use y, hy;
  exact h V y;

lemma validAxiomFour_of_transitive {p : Formula Œ±} {F : PLoN.Frame Œ±} (hTrans : F.TransitiveOnFormula p) : F ‚äß Axioms.Four p := by
  dsimp [Axioms.Four];
  intro V x h y rxy z ryz;
  exact h (hTrans rxy ryz);


abbrev TransitiveFrameClass (Œ±) : PLoN.FrameClass Œ± := { F | Frame.Transitive F }

lemma TransitiveFrameClass.nonempty : (TransitiveFrameClass.{_, 0} Œ±).Nonempty := by
  use terminalFrame Œ±;
  simp [Frame.Transitive, Frame.TransitiveOnTheory, Frame.TransitiveOnFormula];


abbrev SerialFrameClass (Œ±) : PLoN.FrameClass Œ± := { F | Frame.Serial F }

lemma SerialFrameClass.nonempty : (SerialFrameClass.{_, 0} Œ±).Nonempty := by
  use terminalFrame Œ±;
  simp [Frame.Serial, Frame.SerialOnTheory, Frame.SerialOnFormula];
  intro p x; use x;


abbrev TransitiveSerialFrameClass (Œ±) : PLoN.FrameClass Œ± := { F | F.Transitive ‚àß F.Serial }

lemma TransitiveSerialFrameClass.nonempty : (TransitiveSerialFrameClass.{_, 0} Œ±).Nonempty := by
  use terminalFrame Œ±;
  simp [Frame.Transitive, Frame.TransitiveOnTheory, Frame.TransitiveOnFormula, Frame.Serial, Frame.SerialOnTheory, Frame.SerialOnFormula];
  intro p x; use x;


lemma N4_characterized : ùêçùüí.CharacterizedByPLoNFrameClass (TransitiveFrameClass Œ±) := by
  intro F;
  simp [DeductionParameter.theory, System.theory, PLoN.ValidOnFrame, PLoN.ValidOnModel];
  intro hTrans p hp;
  induction hp using Deduction.inducition_with_necOnly! with
  | hMaxm h =>
    obtain ‚ü®p, e‚ü© := h; subst e;
    exact validAxiomFour_of_transitive $ hTrans p (by simp_all);
  | hMdp ihpq ihp => exact PLoN.ValidOnFrame.mdp ihpq ihp;
  | hNec ihp => exact PLoN.ValidOnFrame.nec ihp;
  | hOrElim => exact PLoN.ValidOnFrame.disj‚ÇÉ;
  | _ => simp_all [PLoN.Satisfies];

lemma NRosser_characterized : ùêç(ùêë).CharacterizedByPLoNFrameClass (SerialFrameClass Œ±) := by
  intro F;
  simp [DeductionParameter.theory, System.theory, PLoN.ValidOnFrame, PLoN.ValidOnModel];
  intro hSerial p hp;
  induction hp using Deduction.inducition! with
  | hMaxm h => simp at h;
  | hMdp ihpq ihp => exact PLoN.ValidOnFrame.mdp ihpq ihp;
  | hRules rl hrl hant ih =>
    rcases hrl with (hNec | hRosser)
    . obtain ‚ü®p, e‚ü© := hNec; subst e; simp_all;
      exact PLoN.ValidOnFrame.nec ih;
    . obtain ‚ü®p, e‚ü© := hRosser; subst e; simp_all;
      exact validRosserRule_of_serial (hSerial p (by simp_all)) ih;
  | hOrElim => exact PLoN.ValidOnFrame.disj‚ÇÉ;
  | _ => simp_all [PLoN.Satisfies];

-- TODO: `theory ùêçùüí ‚à™ theory ùêç(ùêë) = theory ùêçùüí(ùêë)`„Å®„ÅÑ„ÅÜ‰∫ãÂÆü„ÇíÁ§∫„Åõ„Å∞ÂÖ±ÈÄöÈÉ®ÂàÜ„Å†„Åë„ÅßÁ∞°Âçò„Å´ÁâπÂæ¥„Å•„Åë„Çâ„Çå„ÇãÊ∞ó„Åå„Åô„Çã
lemma N4Rosser_characterized : ùêçùüí(ùêë).CharacterizedByPLoNFrameClass (TransitiveSerialFrameClass Œ±) := by
  intro F;
  simp [DeductionParameter.theory, System.theory, PLoN.ValidOnFrame, PLoN.ValidOnModel];
  intro hTrans hSerial p hp;
  induction hp using Deduction.inducition! with
  | hMaxm h =>
    obtain ‚ü®p, e‚ü© := h; subst e;
    exact validAxiomFour_of_transitive $ hTrans p (by simp_all);
  | hMdp ihpq ihp => exact PLoN.ValidOnFrame.mdp ihpq ihp;
  | hRules rl hrl hant ih =>
    rcases hrl with (hNec | hRosser)
    . obtain ‚ü®p, e‚ü© := hNec; subst e; simp_all;
      exact PLoN.ValidOnFrame.nec ih;
    . obtain ‚ü®p, e‚ü© := hRosser; subst e; simp_all;
      exact validRosserRule_of_serial (hSerial (‚ñ°p) (by simp_all)) ih;
  | hOrElim => exact PLoN.ValidOnFrame.disj‚ÇÉ;
  | _ => simp_all [PLoN.Satisfies];


end PLoN

end LO.Modal.Standard
